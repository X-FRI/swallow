#ifndef SWALLOW_COMPILER_AST_HPP
#define SWALLOW_COMPILER_AST_HPP

#include "compiler.h"
#include "error/errors.hpp"
#include "gmachine/environment.hpp"
#include "gmachine/instruction.hpp"
#include "parser/location.hh"
#include "type/environment.hpp"
#include "type/type.hpp"
#include "utils/binop.hpp"
#include <cstdint>
#include <memory>
#include <string>
#include <vector>

namespace swallow::compiler::ast
{

  /** The base class of expressions */
  class AST
  {

  public:
    using Ptr = std::unique_ptr<AST>;

    /** The location of the current expression in the source file.
     ** (generated by Bison, passed in parser.y) */
    const yy::location Location;

    type::Type::Ptr NodeType;

    explicit AST(const yy::location Location) : Location(Location) {}

    virtual ~AST() = default;

    /** This function calls TypeCheck,
     ** stores the result in NodeType and returns NodeType */
    auto CommonTypeCheck(
      type::Manager &typeManager, const type::Environment &typeEnvironment)
      -> type::Type::Ptr;

    void CommonResolve(const type::Manager &typeManager);

    virtual void Resolve(const type::Manager &typeManager) = 0;

    virtual auto TypeCheck(
      type::Manager           &typeManager,
      const type::Environment &typeEnvironment) const -> type::Type::Ptr = 0;

    virtual void Dump(uint8_t indent, std::ostream &to) const = 0;

    virtual void Compile(
      const gmachine::Environment::Ptr                     &machineEnvironment,
      std::vector<gmachine::instruction::Instruction::Ptr> &into) const = 0;
  };

  class Definition
  {
  public:
    using Ptr = std::unique_ptr<Definition>;

    const yy::location Location;

    explicit Definition(const yy::location Location) : Location(Location) {}

    virtual ~Definition() = default;

    virtual void PreScanTypes(
      type::Manager &typeManager, type::Environment &typeEnvironment) = 0;

    virtual void Resolve(const type::Manager &typeManager) = 0;

    virtual void TypeCheck(
      type::Manager           &typeManager,
      const type::Environment &typeEnvironment) const = 0;

    virtual void Compile() = 0;
  };

  class Pattern
  {
  public:
    using Ptr = std::unique_ptr<Pattern>;

    const yy::location Location;

    explicit Pattern(const yy::location &Location) : Location(Location) {}

    virtual ~Pattern() = default;

    virtual void Match(
      type::Type::Ptr    type,
      type::Manager     &typeManager,
      type::Environment &typeEnvironment) const = 0;

    virtual void Dump(std::ostream &to) const = 0;
  };

  class Branch
  {
  public:
    using Ptr = std::unique_ptr<Branch>;

    const yy::location Location;
    const Pattern::Ptr Patt;
    const AST::Ptr     Expr;

    Branch(const yy::location &Location, Pattern::Ptr Patt, AST::Ptr Expr)
      : Patt(std::move(Patt)), Expr(std::move(Expr)), Location(Location)
    {}
  };

  class Constructor
  {
  public:
    using Ptr = std::unique_ptr<Constructor>;

    const std::string              Name;
    const std::vector<std::string> Types;
    const yy::location             Location;
    uint8_t                        Tag{};

    Constructor(
      const yy::location       Location,
      std::string              Name,
      std::vector<std::string> Types)
      : Name(std::move(Name)), Types(std::move(Types)), Location(Location)
    {}
  };

  class Int final : public AST
  {
    const int Value;

  public:
    explicit Int(const yy::location &Location, const int V)
      : Value(V), AST(Location)
    {}

    auto TypeCheck(
      type::Manager           &typeManager,
      const type::Environment &typeEnvironment) const
      -> type::Type::Ptr override;

    void Dump(uint8_t indent, std::ostream &to) const override;

    void Compile(
      const gmachine::Environment::Ptr &machineEnvironment,
      std::vector<gmachine::instruction::Instruction::Ptr> &into) const override;

    void Resolve(const type::Manager &typeManager) override;
  };

  class LID final : public AST
  {
    const std::string ID;

  public:
    explicit LID(const yy::location &Location, std::string ID)
      : ID(std::move(ID)), AST(Location)
    {}

    auto TypeCheck(
      type::Manager           &typeManager,
      const type::Environment &typeEnvironment) const
      -> type::Type::Ptr override;

    void Dump(uint8_t indent, std::ostream &to) const override;

    void Compile(
      const gmachine::Environment::Ptr &machineEnvironment,
      std::vector<gmachine::instruction::Instruction::Ptr> &into) const override;
    void Resolve(const type::Manager &typeManager) override;
  };

  class UID final : public AST
  {
    const std::string ID;

  public:
    explicit UID(const yy::location Location, std::string ID)
      : ID(std::move(ID)), AST(Location)
    {}

    auto TypeCheck(
      type::Manager           &typeManager,
      const type::Environment &typeEnvironment) const
      -> type::Type::Ptr override;

    void Dump(uint8_t indent, std::ostream &to) const override;

    void Compile(
      const gmachine::Environment::Ptr &machineEnvironment,
      std::vector<gmachine::instruction::Instruction::Ptr> &into) const override;
    void Resolve(const type::Manager &typeManager) override;
  };

  class Binop final : public AST
  {
  public:
    const utils::Binop Operator;
    const Ptr          Left;
    const Ptr          Right;

    Binop(
      const yy::location Location, utils::Binop Operator, Ptr Left, Ptr Right)
      : Operator(Operator)
      , Left(std::move(Left))
      , Right(std::move(Right))
      , AST(Location)
    {}

    static auto OperatorToString(utils::Binop op) -> std::string;

    auto TypeCheck(
      type::Manager           &typeManager,
      const type::Environment &typeEnvironment) const
      -> type::Type::Ptr override;

    void Dump(uint8_t indent, std::ostream &to) const override;

    void Compile(
      const gmachine::Environment::Ptr &machineEnvironment,
      std::vector<gmachine::instruction::Instruction::Ptr> &into) const override;

    void Resolve(const type::Manager &typeManager) override;
  };

  class Application final : public AST
  {
    const Ptr Left;
    const Ptr Right;

  public:
    Application(const yy::location Location, Ptr Left, Ptr Right)
      : Left(std::move(Left)), Right(std::move(Right)), AST(Location)
    {}

    auto TypeCheck(
      type::Manager           &typeManager,
      const type::Environment &typeEnvironment) const
      -> type::Type::Ptr override;

    void Dump(uint8_t indent, std::ostream &to) const override;

    void Compile(
      const gmachine::Environment::Ptr &machineEnvironment,
      std::vector<gmachine::instruction::Instruction::Ptr> &into) const override;
    void Resolve(const type::Manager &typeManager) override;
  };

  class Match final : public AST
  {
    const Ptr                      With;
    const std::vector<Branch::Ptr> Branches;

  public:
    Match(const yy::location Location, Ptr o, std::vector<Branch::Ptr> b)
      : With(std::move(o)), Branches(std::move(b)), AST(Location)
    {}

    auto TypeCheck(
      type::Manager           &typeManager,
      const type::Environment &typeEnvironment) const
      -> type::Type::Ptr override;

    void Dump(uint8_t indent, std::ostream &to) const override;

    void Compile(
      const gmachine::Environment::Ptr &machineEnvironment,
      std::vector<gmachine::instruction::Instruction::Ptr> &into) const override;

    void Resolve(const type::Manager &typeManager) override;
  };

  class VariablePattern final : public Pattern
  {
    const std::string Variable;

  public:
    explicit VariablePattern(const yy::location Location, std::string Variable)
      : Variable(std::move(Variable)), Pattern(Location)
    {}

    void Match(
      type::Type::Ptr    type,
      type::Manager     &typeManager,
      type::Environment &typeEnvironment) const override;

    void Dump(std::ostream &to) const override;
  };

  class ConstructorPattern final : public Pattern
  {
  public:
    const std::string              ConstructorName;
    const std::vector<std::string> Params;

    ConstructorPattern(
      const yy::location       Location,
      std::string              Constructor,
      std::vector<std::string> Params)
      : ConstructorName(std::move(Constructor))
      , Params(std::move(Params))
      , Pattern(Location)
    {}

    void Match(
      type::Type::Ptr    type,
      type::Manager     &typeManager,
      type::Environment &typeEnvironment) const override;

    void Dump(std::ostream &to) const override;
  };

  class Fn final : public Definition
  {
  public:
    const std::string                                    Name;
    const std::vector<std::string>                       Params;
    const AST::Ptr                                       Body;
    std::vector<gmachine::instruction::Instruction::Ptr> Instructions;

    std::vector<type::Type::Ptr> ParamTypes;
    type::Type::Ptr              ReturnType;

    Fn(
      const yy::location       Location,
      std::string              Name,
      std::vector<std::string> Params,
      AST::Ptr                 Body)
      : Name(std::move(Name))
      , Params(std::move(Params))
      , Body(std::move(Body))
      , Definition(Location)
    {}

    void PreScanTypes(
      type::Manager &typeManager, type::Environment &typeEnvironment) override;

    void TypeCheck(
      type::Manager           &typeManager,
      const type::Environment &typeEnvironment) const override;
    void Resolve(const type::Manager &typeManager) override;
    void Compile() override;
  };

  class Data final : public Definition
  {
  public:
    const std::string                   Name;
    const std::vector<Constructor::Ptr> Constructors;

    Data(
      const yy::location            Location,
      std::string                   Name,
      std::vector<Constructor::Ptr> Constructors)
      : Name(std::move(Name))
      , Constructors(std::move(Constructors))
      , Definition(Location)
    {}

    void PreScanTypes(
      type::Manager &typeManager, type::Environment &typeEnvironment) override;
    void TypeCheck(
      type::Manager           &typeManager,
      const type::Environment &typeEnvironment) const override;
    void Resolve(const type::Manager &typeManager) override;
    void Compile() override;
  };

  void Dump(const std::vector<Definition::Ptr> &Program);
} // namespace swallow::compiler::ast

namespace swallow::compiler::type
{
  void TypeCheck(
    const std::vector<ast::Definition::Ptr> &program,
    const CompilerOptions                   &options);
} // namespace swallow::compiler::type

namespace swallow::compiler::gmachine
{
  void Compile(
    const std::vector<ast::Definition::Ptr> &program,
    const CompilerOptions                   &options);
}

#endif